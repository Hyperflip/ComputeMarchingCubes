#pragma kernel MeshConstructor

#include "Common.hlsl"

// Parameters
uint MaxTriangle;
uint3 Dims;
float IsoValue;

// Output triangle buffer
RWStructuredBuffer<Triangle> Output;

// Triangle look up table for each cube configuration
StructuredBuffer<uint2> TriangleTable;

uint VertexFromTriangleTable(uint2 data, uint index)
{
    return 0xfu & (index < 8 ? data.x >> ((index + 0) * 4) :
                               data.y >> ((index - 8) * 4));
}

// Input voxel
StructuredBuffer<float> Voxels;

float VoxelValue(uint x, uint y, uint z)
{
    return Voxels[x + Dims.x * (y + Dims.y * z)];
}

// Voxel sampling with gradient calculation
float4 VoxelSample(uint3 i)
{
    uint3 i_n = max(i, 1) - 1;
    uint3 i_p = min(i + 1, Dims - 1);

    float v = VoxelValue(i.x, i.y, i.z);
    float v_nx = VoxelValue(i_n.x, i.y, i.z);
    float v_px = VoxelValue(i_p.x, i.y, i.z);
    float v_ny = VoxelValue(i.x, i_n.y, i.z);
    float v_py = VoxelValue(i.x, i_p.y, i.z);
    float v_nz = VoxelValue(i.x, i.y, i_n.z);
    float v_pz = VoxelValue(i.x, i.y, i_p.z);

    return float4(v_px - v_nx, v_py - v_ny, v_pz - v_nz, v);
}

// Cube helper functions
uint3 CubeVertex(uint index)
{
    bool x = index & 1;
    bool y = index & 2; bool z = index & 4;
    return uint3(x ^ y, y, z);
}

uint2 EdgeVertexPair(uint index)
{
    // (0,1) (1,2) (2,3) (3,0)
    // (4,5) (5,6) (6,7) (7,4)
    // (0,4) (1,5) (2,6) (3,7)
    uint v1 = index & 7;
    uint v2 = index < 8 ? ((index + 1) & 3) | (index & 4) : v1 + 4;
    return uint2(v1, v2);
}

//
// Marching cube kernel function
//
[numthreads(4, 4, 4)]
void MeshConstructor(uint3 id : SV_DispatchThreadID)
{
    // Boundary check
    if (any(id + 1 >= Dims.xyz)) return;

    // Voxel samples at each cube vertex
    float4 samples[8];
    for (uint i = 0; i < 8; i++)
        samples[i] = VoxelSample(id + CubeVertex(i));

    // Cube configuration selector as a bit field of vertex binary states
    uint selector = 0;
    for (i = 0; i < 8; i++)
        selector |= (samples[i].w < IsoValue) << i;

    // Special case for empty cubes; Exit ealy if there is no intersection.
    if (selector == 0 || selector == 0xff) return;

    // Intersection points on each edge
    // Do it in the GPU's way! We do calculation on all the edges, even on
    // edges without intersection.
    Point points[12];
    for (i = 0; i < 12; i++)
    {
        uint2 pair = EdgeVertexPair(i);
        float4 sample1 = samples[pair.x];
        float4 sample2 = samples[pair.y];
        float3 vertex1 = id + CubeVertex(pair.x);
        float3 vertex2 = id + CubeVertex(pair.y);

        float param = (IsoValue - sample1.w) / (sample2.w - sample1.w);
        float3 p = lerp(vertex1, vertex2, param);
        float3 n = normalize(lerp(sample1.xyz, sample2.xyz, param));

        points[i] = MakePoint(p, n);
    }

    uint2 tri_data = TriangleTable[selector];
    for (i = 0; i < 15; i += 3)
    {
        uint v1 = VertexFromTriangleTable(tri_data, i);
        uint v2 = VertexFromTriangleTable(tri_data, i + 2);
        uint v3 = VertexFromTriangleTable(tri_data, i + 1);
        if (v1 == 15) return;

        uint count = Output.IncrementCounter();
        if (count >= MaxTriangle) return;

        Output[count] = MakeTriangle(points[v1], points[v2], points[v3]);
    }
}
